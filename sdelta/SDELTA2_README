sdelta2 demonstrates that better/smaller compressed delta files
remains possibile at the cost of additional CPU and memory which
in this case about 2.5x CPU and 1.25 memory.

Like sdelta sdelta2 still uses a flawed method for finding matches
by creating blocks and finding at a minimum 2 consecutive matching blocks.
It is flawed in the respect that it creates blind spots
in order to conserve memory and expedite match finding.
However sdelta2 attempts to better position and look within blindspots.
sdelta2 has a more complex set of rules for block generation
that uses line feed, point, slash and NULL as block terminators.
However to avoid creating too many blocks which would waste
memory it colates adjacent blocks of size 1 into a single block,
so that a string of NULL for example would not become a 
commensurate increase in blocks.

When sdelta 2 finds a sequence of matching blocks it looks in
front and behind the sequence for additional matching bytes.
Then it selects for the match the largest sequence of matching bytes.
By doing this it can scrape up a slightly larger match than
sdelta and avoid replicating in unmatched data a few bytes 
of what sdelta must.
By having more advantageously placed blocks and scavenging bytes
at the tip and tail of matching block sequences sdelta2 can make
some very tiny patch files that compress 5% to 60% smaller than
sdelta patch files.

The reason that the gains are not incredible is because sdelta
already has a fantastic algorithim for creating delta files.
About the only area that sdelta2 exceeds sdelta on source tarballs
is in reducing the amount of tarfile metadata that becomes part
of the unmatched data.  Because the tarfile metadata is delinated
with series of NULLs instead of line feeds sdelta has many 
unadvantageously placed blind spots when attempting to match it.

In both sdelta and sdelta2 patches for typical source tarballs
much of the match references and unmatched data is entirely 
about tarball metadata, because the source files themselves
are usually almost entirely the same.
Much of the mass of a sdelta and sdelta2 patch is created
by a change of directory and change of timestamp.

Take the differences between linux-2.6.11.6.tar and linux-2.6.11.7.tar
as an example.

One tarball contains the string:
linux-2.6.11.7/drivers/media/video/saa7110.c

while the other has:
linux-2.6.11.6/drivers/media/video/saa7110.c

Although it is a single byte difference it is a change
that has to be expressed in the delta file.

Also the timestamp of the file has changed because likely
in order to make the new release the software author did
something like:

cp  -r linux-2.6.11.6  linux-2.6.11.7
and therefore every file in the tarball 
has a new path and new time stamp even
when the contents of the file is not modified.

If neither the path nor the time stamp for each
unmodified file is changed then the delta file 
by both sdelta and sdelta2 would be much smaller.
While it might be possibile to do a search and 
replace to correct the modified path it will
not work for correcting modified time stamps.
However sdelta2 is better able to match tarball
metadata and therefore by this savings alone can
create smaller compressed patch files than sdelta.

The goal of sdelta and sdelta2 is to
create delta files for source tarballs that make 
exact byte for byte replications of the original.
diff/patch does not have this burdon and therefore,
can create smaller deltas than sdelta and sdelta2.
However diff/patch can not be used on tarballs or binary files.
When a untarred source tress is patched with a diff file and
then retarred the tarball will not be a byte for byte replication.

The way to make sdelta and sdelta2 compressed patch files
sizes smaller than diff/patch is to not cp unmodified files
and not change the directory path of every single file
in the tarball.
If the container directory in the above example was
simply linux without a -version_number appended to
it then that would solve 1 of the 2 problems that
create mass in sdelta patch files.  cp -a would
solve the second problem.
